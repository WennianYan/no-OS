// >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
// ------------------------------------------------------------------
// Copyright (c) 2019-2020 by Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// ------------------------------------------------------------------
//
// IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPELâ„¢
// DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.
//
// Lattice grants permission to use this code pursuant to the
// terms of the Lattice Propel License Agreement.
//
// DISCLAIMER:
//
//  LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS, WHETHER
//  EXPRESSED, IMPLIED, STATUTORY, OR IN ANY PROVISION OF THE LATTICE
//  PROPEL LICENSE AGREEMENT OR COMMUNICATION WITH LICENSEE, AND LATTICE
//  SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF MERCHANTABILITY OR
//  FITNESS FOR A PARTICULAR PURPOSE.  LATTICE DOES NOT WARRANT THAT THE
//  FUNCTIONS CONTAINED HEREIN WILL MEET LICENSEE'S REQUIREMENTS, OR THAT
//  LICENSEE'S OPERATION OF ANY DEVICE, SOFTWARE OR SYSTEM USING THIS FILE
//  OR ITS CONTENTS WILL BE UNINTERRUPTED OR ERROR FREE, OR THAT DEFECTS
//  HEREIN WILL BE CORRECTED.  LICENSEE ASSUMES RESPONSIBILITY FOR
//  SELECTION OF MATERIALS TO ACHIEVE ITS INTENDED RESULTS, AND FOR THE
//  PROPER INSTALLATION, USE, AND RESULTS OBTAINED THEREFROM.  LICENSEE
//  ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING DEFECTIVE
//  OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT, LICENSEE SHALL
//  ASSUME THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE, CORRECTION, OR
//  ANY OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE
//  SOFTWARE.  IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT,
//  INDIRECT,SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST
//  PROFITS, ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS, EVEN IF
//  LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. LATTICE'S
//  SOLE LIABILITY, AND LICENSEE'S SOLE REMEDY, IS SET FORTH ABOVE.
//  LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE, ITS CONTENTS OR
//  USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES' INTELLECTUAL PROPERTY
//  RIGHTS, INCLUDING ANY PATENT. IT IS THE USER'S RESPONSIBILITY TO VERIFY
//  THE USER SOFTWARE DESIGN FOR CONSISTENCY AND FUNCTIONALITY THROUGH THE
//  USE OF FORMAL SOFTWARE VALIDATION METHODS.
// ------------------------------------------------------------------

/* Portions Copyright (c) 2023 Analog Devices, Inc. */

#include "uart.h"
#include "gpio.h"
#include "pic.h"
#include <stdio.h>
#include "i2c_master.h"
#include "spi_master.h"
#include <stdlib.h>
#include "tmc/ic/TMC5130/TMC5130.h"
#include "hal/Systick.h"

TMC5130TypeDef tmc5130;
ConfigurationTypeDef conf;
ConfigurationTypeDef *config = &conf;

#define TMC5130 tmc5130

#define STOP 0
#define ROTATE_LEFT 1
#define ROTATE_RIGHT 2

struct uart_instance uart_core_uart;
struct gpio_instance gpio_inst;
struct spim_instance spi_inst;
struct i2cm_instance i2c_inst;

static uint8_t reset()
{
	if(!tmc5130_readInt(&TMC5130, TMC5130_VACTUAL))
		tmc5130_reset(&TMC5130);

	return 1;
}

static uint8_t restore()
{
	return tmc5130_restore(&TMC5130);
}

static void configCallback(TMC5130TypeDef *tmc5130, ConfigState completedState)
{
	if(completedState == CONFIG_RESET)
	{
		// Configuration reset completed
		// Change hardware preset registers here
		tmc5130_writeInt(tmc5130, TMC5130_PWMCONF, 0x000500C8);

		// Fill missing shadow registers (hardware preset registers)
		tmc5130_fillShadowRegisters(&TMC5130);
	}
}

void tmc5130_readWriteArray(uint8_t channel, uint8_t *data, size_t length)
{
	spi_master_readwrite(&spi_inst, data, length);
}

int main(void) {
	static uint8_t idx = 0;
	static uint8_t pin_state = 0xFF;

	//initialize GPIO
	gpio_inst.instance_name = GPIO0_INST_NAME;
	gpio_init(&gpio_inst, GPIO0_INST_BASE_ADDR, GPIO0_INST_LINES_NUM, GPIO0_INST_GPIO_DIRS);

	spi_master_init(&spi_inst,
			SPI0_INST_BASE_ADDR,
			SPI0_INST_SLAVE_COUNT,
			SPI0_INST_DATA_WIDTH,
			SPI0_INST_CPOL,
			SPI0_INST_CPHA,
			SPI_IRQ_DISABLE);

	spi_master_config(&spi_inst,
			SPIM_DATA_WIDTH_8BIT,
			SPI0_INST_PRESCALER,
			SPI0_INST_CPOL,
			SPI0_INST_CPHA,
			SPI_SSNP_DISABLE);

#if _UART_ENABLE_INTERRUPTS_
	//setup uart IRQ
	pic_init(CPU0_INST_PICTIMER_START_ADDR);
	systick_init();
	uart_core_uart.intrLevel = UART0_INST_IRQ;
	pic_isr_register(UART0_INST_IRQ, uart_isr, (void *)&uart_core_uart);
#endif

	uart_init(&uart_core_uart,
			UART0_INST_BASE_ADDR,
			CPU_FREQUENCY,
			UART0_INST_BAUD_RATE,
			UART0_INST_STOP_BITS,
			UART0_INST_DATA_WIDTH);

	config->reset = reset;
	config->restore = restore;
	config->state = CONFIG_RESET;
	config->configIndex = 0;

	tmc5130_init(&TMC5130, 0/*channel*/, config, &tmc5130_defaultRegisterResetState[0]);
	TMC5130.config->reset();
	tmc5130_setCallback(&TMC5130, configCallback);

#ifdef LSCC_STDIO_UART_APB
	extern struct uart_instance *g_stdio_uart;
	g_stdio_uart = &uart_core_uart;
#endif

	printf("Hello RISC-V TRINAMIC!\r\n");

	char str[32];
	int velocity = 10000;
	int state = ROTATE_RIGHT;

	while (true) {
//		gpio_output_write(&gpio_inst, idx, pin_state);

//		printf("pin_state: %d\n", pin_state);

//		if (++idx == LED_COUNT) {
//			idx = 0;
//			pin_state = ~pin_state;
//		}

//      this calls the configuration procedure if it was not yet called. // writeConfiguration(&TMC5130);
		tmc5130_periodicJob(&tmc5130, systick_getTick());
//		printf("systick %d\n",systick_getTick());
//		printf("velocity: %d\n",tmc5130.velocity); //It gives 0 when the

		if(TMC5130.config->state == CONFIG_READY){

			//set acceleration
			tmc5130_writeInt(&tmc5130, TMC5130_AMAX,60000);

			uart_getc(&uart_core_uart, str);

			switch(str[0]){
				case 'w':
					//incrace velocity
					if(velocity < 200000){
						velocity += 10000;
						printf("incrace velocity, ");
					}
					switch(state){
						case STOP:
							tmc5130_stop(&tmc5130);
							printf("stop\n");
						break;
						case ROTATE_LEFT:
							tmc5130_left(&tmc5130,velocity);
							printf("rotate left\n");
						break;
						case ROTATE_RIGHT:
							tmc5130_right(&tmc5130,velocity);
							printf("rotate right\n");
						break;
					}
					str[0] = 0;
				break;
				case 's':
					//decrace velocity
					if(velocity > 0){
						velocity -= 10000;
						printf("decrace velocity, ");
					}
					switch(state){
						case STOP:
							tmc5130_stop(&tmc5130);
							printf("stop\n");
						break;
						case ROTATE_LEFT:
							tmc5130_left(&tmc5130,velocity);
							printf("rotate left\n");
						break;
						case ROTATE_RIGHT:
							tmc5130_right(&tmc5130,velocity);
							printf("rotate right\n");
						break;
					}
					str[0] = 0;
				break;
				case 'a':
					//rotate left
					tmc5130_left(&tmc5130,velocity);
					state = ROTATE_LEFT;
					str[0] = 0;
					printf("rotate left\n");
				break;
				case 'd':
					//rotate right
					tmc5130_right(&tmc5130,velocity);
					state = ROTATE_RIGHT;
					str[0] = 0;
					printf("rotate right\n");
				break;
				case 'q':
					//stop
					tmc5130_stop(&tmc5130);
					state = STOP;
					str[0] = 0;
					printf("stop\n");
				break;
			}

			wait(50);
		}
	}

	return 0;
}

